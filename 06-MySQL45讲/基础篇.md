# 基础篇

## 基础架构:一条SQL查询语句是如何执行的

Server层

> 覆盖MySQL的大多数核心服务功能,以及所有的内置函数(比如日期,时间,数学和加密函数等).所有跨存储引擎的功能都在这一层实现,比如存储过程,触发器,视图等;

* 连接器 管理连接 权限验证

```
连接器在建立连接的时候验证权限,如果中间有权限调整,只有新建的连接才使用新的权限配置;
show proceslist 可以看到MySQL服务的连接状态;客户端连接的时长是通过参数wait_timeout决定的;
数据库里面,长连接是指连接成功后,如果客户端持续请求,则一直使用同一个连接;短连接是指每次执行完很少的几次查询就断开连接,下次查询再次建立一个;
建立连接的过程通常是比较复杂的,建议尽量减少建立连接的动作,也就是尽量使用长连接;
使用长连接多了以后会发现MySQL的内存占用会涨的厉害;这是因为MySQL在执行过程中临时使用的内存是管理在连接对象里面的,这些资源会在连接断开后才会释放,所以如果长连接累积下来,可能会导致内存太大,被操作系统强行杀掉(OOM).从现象看就是MySQL服务重启了.遇到这种情况,可以考虑以下两种方案:
1. 定时断开长连接,使用一段时间或者程序里面判断执行过一个占用内存的大查询后,断开连接,之后要查询再重连;
2. MySQL5.7可以通过执行 mysql_reset_connection 来重新初始化连接资源,这个过程不需要重连和权限验证,但是会将连接恢复到刚刚创建完的状态;
```



* 查询缓存 命中则直接返回结构

> MySQL8.0之后将查询缓存的整块功能删掉了,所以MySQL8.0之后没有了这个功能;

* 分析器 词法分析,语法分析

* 优化器 执行计划生成,索引选择

* 执行器 操作引擎,返回结果

> 执行器在执行之前会判断当前用户有没有查询表,视图或者触发器等权限,如果没有,则会提示没有权限的错误;



存储引擎

> 负责数据的存储和读取,其架构模式是插件式的.支持InnoDB,MyISAM,Memory引擎等;



## 日志系统:一条SQL更新语句是如何执行的

连接器连接数据库;

清空这个表的查询缓存;

分析器判断这个是一个更新语句;

优化器决定是否使用索引;

执行器负责执行;

**更新流程中涉及两个重要的日志模块: redo log(重做日志)和binlog(归档日志)**

### redo log

Redo log 是 InnoDB引擎特有的;有了redo log,InnoDB就可以保证即使数据库发生异常重启,之前提交的记录也不会丢失,这个能力叫做**crash-safe**

```
InnoDB引擎中redo log的大小是固定的,比如可以配置一组4个文件,每个大小是1G,那么就能记录4Gb的操作;从头开始,写到尾部就又开始从头部写入;
如果写满了就要停止更新操作,擦除一些记录然后继续记录;擦除的这部分记录就是要写入磁盘;
```

### binlog

binlog 是 MySQL Server层的日志;

binlog 有两种模式

* statement 格式记录的是sql语句;
* row格式记录行的内容,记两条,更新前和更新后;

binlog 和 redo log的区别

* redo log 是InnoDB里面特有的;binlog是MySQL的Server层实现的,所有引擎都可以使用;
* redo log 是物理日志,记录的是 在某个数据页上做了什么修改; binlog是逻辑日志,记录的是这个语句的原始逻辑,比如给id=2这一行的c字段加1;
* redo log 是循环写入的,空间固定会用完;binlog是可以追加写入的.追加写是指binlog文件写到一定大小后会切换到下一个,并不会覆盖之前的日志;



执行器和InnoDB引擎在执行更新语句时的内部流程

1. 执行器找到id=2这一行;(id是主键可以用树搜索找到该行,否则就要从磁盘读取加载到内存)
2. 执行器拿到数据,把值加1;(比如原来是N,现在就是N+1.得到新的一行数据,再调用引擎写入这行数据)
3. 引擎将这行数据更新到内存中,同时将这个更新记录写入到redo log.此时redo log处于prepare状态,然后告知执行器执行完成,随时可以提交事务;
4. 执行器生成这个操作的binlog,并把binlog记录到磁盘;
5. 执行器调用引擎的提交事务接口,引擎把刚刚醒接入的redo log 改成提交(commit)状态,更新完成;

```
redo log的执行分为 prepare 和 commit;这就是 二阶段提交;
为什么使用二阶段提交?
为了让两份日志之间的逻辑一致;
如果先写redo log再写binlog;写入redo log后事务已经提交;binlog未写入就crash的情况下,用binlog恢复就会缺失一条记录;
如果先写binlog再写redo log;写入binlog后crash,redo log未写入相当于事务失败,用binlog恢复的时候就会多一条记录;
```

### 总结

redo log 保证了crash safe的能力. `innodb_flush_log_at_trx_commit`参数设置为1表示每次事务的redo都持久化到磁盘;这个参数建议设置为1,保证MySQL异常重启后数据不丢失;

`sync_binlog`这个参数设置为1时,表示每次事务的binlog都持久化到磁盘.这个参数建议设置为1,可以保证MySQL异常重启后binlog不丢失;



## 事务隔离级别

在MySQL中,事务是在引擎层实现的.比如InnoDB支持事务;MyISAM不支持事务;

事务 ACID

SQL标准的事务的隔离级别

* 读未提交
* 读已提交
* 可重复读
* 串行化

```
在实现上,数据库会创建一个视图(Read-View),访问的时候以视图的逻辑结果为准.
在可重复读隔离级别下,视图是在事务启动的时候创建的,整个事务在期间都使用这个视图;
在读已提交隔离级别下,视图在每个SQL语句执行的时候创建;
读未提交隔离级别下,直接返回记录上的最新值,没有视图的概念;
串行化隔离级别下,直接使用加锁的方式来避免并行访问;
```



查看MySQL数据库的隔离级别 `show variables like 'transaction_isolation'`;



```
介绍一个可重复读的场景
银行账户月末对账的时候使用重复读可以保证用户即使在对账过程中发生了交易,也不影响校对的结果;因为重复读场景下,视图在事务启动的时候就创建了.
```

### 事务隔离性的实现

MVCC 多版本控制;

尽量不要使用长事务

* 长事务要保证undo日志里面要保存多分read view;会导致文件过大,占用磁盘空间;
* 导致锁资源一直不释放,拖垮整个库;

MySQL的事务启动方式

* 显式启动语句; `begin`或者`start transaction`;配套的提交是`commit`;回滚是`rollback`.
* `set autocommit=0`,这个命令会将这个线程的自动提交关掉.意味着如果你只执行一个select语句,这个事务就启动了,而且不会自动提交.这个事务持续存在直到你主动执行`commit`或`rollback`,或者断开连接.

建议使用`set automcommit=1`,通过显式语句的方式来启动事务;

```
在使用set autocommit=0的方式下,对于一个频繁使用事务的业务中,不需要每次都显式的主动执行begin,减少了语句的交互次数.如果有这种顾虑,可以使用commit work and chain语法;
在autocommit=1的情况下,用begin显式启动事务,如果执行commit则提交事务.如果执行commit work and chain,则是提交事务并自动启动下一个事务,这样就省去了再次执行begin语句的开销;同时带来的好处是从程序开发的角度明确的知道每个语句是否出在事务中.
```



## 索引

索引的三种模型

* 哈希表 适用于只有等值查询的场景.
* 有序数组
* 搜索树



`innoDB`使用B+索引;

主键索引 主键索引的叶子节点存的整行数据,在InnoDB中,主键索引也被称为聚簇索引(clustered Index)

非主键索引 非主键索引的叶子节点内容是主键的值,在InnoDB中,非主键索引也被称为二级索引(secondary index)

```
基于主键索引和普通索引的查询有什么区别呢
如果语句是select * from T where id =500; 即主键查询方式,则只需要搜索id这块B+树;
如果语句是select * from T where k = 5;即普通索引查询方式,则需要先搜索k索引树,得到id的值为500,再到id索引树搜索一次,这个过程称为回表;
```





### 覆盖索引

### 前缀索引

### 索引下推

